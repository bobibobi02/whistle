// pages/api/posts.ts
import type { NextApiRequest, NextApiResponse } from "next";
import { getServerSession } from "next-auth/next";
import { PrismaClient } from "@prisma/client";
import { authOptions } from "./auth/[...nextauth]";

const prisma = new PrismaClient();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    switch (req.method) {
      case "GET":
        return await handleGET(req, res);
      case "POST":
        return await handlePOST(req, res);
      case "DELETE":
        return await handleDELETE(req, res);
      default:
        res.setHeader("Allow", "GET, POST, DELETE");
        return res.status(405).json({ ok: false, error: "Method not allowed" });
    }
  } catch (err: any) {
    console.error("[api/posts] Unhandled error:", err);
    return res.status(500).json({ ok: false, error: "Internal server error" });
  }
}

async function handleGET(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  // Single post by id: /api/posts?id=POST_ID
  if (typeof id === "string") {
    const post = await prisma.post.findUnique({
      where: { id },
      // Keep this minimal to be schema-agnostic
      select: {
        id: true,
        title: true,
        content: true,
        createdAt: true,
        updatedAt: true,
        // If you store the email directly on the post:
        // @ts-ignore
        userEmail: true as any,
        // If you have a related user record:
        // @ts-ignore
        user: { select: { id: true, name: true, email: true } } as any,
      },
    });

    return res.status(200).json({ ok: true, post });
  }

  // List posts: /api/posts
  const posts = await prisma.post.findMany({
    orderBy: { createdAt: "desc" },
    take: 20,
    select: {
      id: true,
      title: true,
      content: true,
      createdAt: true,
      // @ts-ignore
      userEmail: true as any,
      // @ts-ignore
      user: { select: { id: true, name: true, email: true } } as any,
    },
  });

  return res.status(200).json({ ok: true, items: posts });
}

async function handlePOST(req: NextApiRequest, res: NextApiResponse) {
  // Require auth to create
  const session = await getServerSession(req, res, authOptions as any);
  const email = session?.user?.email?.toLowerCase() || null;
  if (!email) {
    return res.status(401).json({ ok: false, error: "Unauthorized" });
  }

  const { title, content, subforumId, subforumName } = (req.body ?? {}) as {
    title?: string;
    content?: string;
    subforumId?: string;
    subforumName?: string;
  };

  if (!title) return res.status(400).json({ ok: false, error: "Missing title" });

  // Try to connect a subforum if you have that relation; otherwise ignore
  let subforumConnect: any = undefined;
  if (subforumId) subforumConnect = { id: subforumId };
  else if (subforumName) subforumConnect = { name: subforumName };

  const data: any = {
    title,
    content: content ?? "",
  };

  // Prefer relation if you have a User model relation on Post:
  // @ts-ignore
  if ((prisma.post as any)?._dmmf) {
    try {
      // Attach by user email if relation exists
      data.user = { connect: { email } };
    } catch {
      // If no relation, fall back to a scalar field on Post (userEmail)
      data.userEmail = email;
    }
  } else {
    data.userEmail = email;
  }

  if (subforumConnect) {
    // If your Post model has a relation named `subforum`
    // @ts-ignore
    data.subforum = { connect: subforumConnect };
  }

  const post = await prisma.post.create({ data });
  return res.status(201).json({ ok: true, post });
}

async function handleDELETE(req: NextApiRequest, res: NextApiResponse) {
  // Accepts /api/posts?id=POST_ID
  const id = typeof req.query.id === "string" ? req.query.id : undefined;
  if (!id) return res.status(400).json({ ok: false, error: "Missing post id" });

  // Require auth
  const session = await getServerSession(req, res, authOptions as any);
  const requesterEmail = session?.user?.email?.toLowerCase();
  if (!requesterEmail) {
    return res.status(401).json({ ok: false, error: "Unauthorized" });
  }

  // Fetch post + owner
  const post = await prisma.post.findUnique({
    where: { id },
    select: {
      id: true,
      // If you store email directly on the post
      // @ts-ignore
      userEmail: true as any,
      // If you have a related user
      // @ts-ignore
      user: { select: { email: true } } as any,
    },
  });

  if (!post) return res.status(404).json({ ok: false, error: "Post not found" });

  const ownerEmail = ((post as any)?.user?.email || (post as any)?.userEmail || "").toLowerCase();
  if (!ownerEmail || ownerEmail !== requesterEmail) {
    return res.status(403).json({ ok: false, error: "Forbidden" });
  }

  try {
    await prisma.$transaction(async (tx) => {
      // Best-effort cleanup if these models exist in your schema
      try {
        await (tx as any).comment?.deleteMany?.({ where: { postId: id } });
      } catch {}
      try {
        await (tx as any).vote?.deleteMany?.({ where: { postId: id } });
      } catch {}
      try {
        await (tx as any).saved?.deleteMany?.({ where: { postId: id } });
      } catch {}
      try {
        await (tx as any).notification?.deleteMany?.({ where: { postId: id } });
      } catch {}

      await tx.post.delete({ where: { id } });
    });

    return res.status(200).json({ ok: true });
  } catch (err: any) {
    console.error("[api/posts] DELETE error:", err);
    return res.status(500).json({ ok: false, error: "Failed to delete post" });
  }
}
